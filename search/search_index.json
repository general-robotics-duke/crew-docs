{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"CREW: Platform for Human-AI Teaming","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>CREW is a platform designed to facilitate Human-AI teaming research, engage collaborations from multiple scientific disciplines, with a strong emphasis on human involvement. It includes pre-built tasks for cognitive studies and Human-AI teaming with expandable potentials from our modular design. Following conventional cognitive neuroscience research, CREW also supports multimodal human physiological signal recording for behavior analysis. Moreover, CREW benchmarks real-time human-guided reinforcement learning agents using state-of-the-art algorithms and well-tuned baselines. </p> <p>CREW is a fully open-sourced project developed by General                       Robotics Lab at Duke                       University.</p>"},{"location":"index.html#overview-of-platform","title":"Overview of Platform","text":"<p>CREW consists of two main subcomponents: <code>Dojo</code> and <code>Algorithms</code>.  These subcomponents work together to create an efficient platform for developers and researchers alike.</p> <p><code>Dojo</code> serves as a Unity package designed specifically to facilitate the development of multiplayer games involving human and AI players. We provide a set of pre-built environments as well as a template for building custom tasks with real-time interaction enabled. </p> <p><code>Algorithms</code>, on the other hand, is a Python package aimed at researchers who wish to create AI agents capable of operating and collaborating with humans within the environments established by <code>Dojo</code>. Offering an intuitive interface, <code>Algorithms</code> ensures maximum flexibility and customizability for the researchers.</p> <p>By working in unison, these two subcomponents create a robust and user-friendly platform for the development of interactive experiences.</p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>To get started with CREW, intall <code>crew-dojo</code> and <code>crew-algorithms</code> from the following github repositories. <pre><code>git clone https://github.com/general-robotics-duke/crew-dojo.git\ngit clone https://github.com/general-robotics-duke/crew-algorithms.git\n</code></pre></p> <p>The specific setup intructions can be found in each repository as well as Dojo Setup and Algorithms Setup</p>"},{"location":"algorithms/intro.html","title":"Algorithms","text":"<p><code>CREW</code> takes every effort to make the algorithms independent of the environments provided, giving as much flexibility as possible to researchers for defining their own algorithms and using whatever libraries they are familiar with. ML-Agents, which centers around this functionaility, wraps up the Unity environments and provides standard interfaces that are common in reinforcement learning research. Additionally, the feature of information channels allows for more diverse feedbacks that researchers may feed to algorithms, leaving space for types beyond just binary rewards.</p> <p>In this part of the documentation, we introduce how to use the interfaces to communicate with the environments from <code>CREW</code>.</p> <p>We then provide human-guided examples implemented by torchrl. In principle, there is no restriction for what libraries to use nor how an algorithm is implemented. It's aimed that the examples get users familiar with the functionalities of <code>CREW</code> and help users to implement their own algorithms with ease.</p>"},{"location":"algorithms/setup.html","title":"Setup Algorithms","text":"<p>Start by cloning the repository: <pre><code>git clone https://github.com/general-robotics-duke/crew-algorithms.git\n</code></pre></p> <p>Then simply enter the folder and run the installation script: <pre><code>cd crew-algorithms\nbash install.sh\n</code></pre></p> <p>If you want to contribute to this repository, you can install the pre-commit hooks for some nice features: <pre><code>poetry run pre-commit install\n</code></pre></p>"},{"location":"algorithms/examples/DeepCoach.html","title":"Algorithm Example: DeepCoach","text":"<p>DeepCoach is one famous reinforcement learning algorithm that trains a policy with human feedbacks. In this tutorial, we give some basic explanation about the algorithm and show the detailed implementation by torchrl. If you are interested in the algorithm and would like to read more, please refer to the paper, in this part of the documentation we aim to provide researchers an illustration on how to use <code>crew</code> for their own algorithms.</p>"},{"location":"algorithms/examples/DeepCoach.html#deepcoach-basics","title":"DeepCoach Basics","text":"<p>The pivotal assumption behind DeepCoach is that human feeback \\(f_{t}\\) at timestep \\(t\\) approximates the discounted return \\(R_{t}=\\sum_{n=t}^{\\infty}\\gamma^{n-t}r_{n}\\) that value functions usually approximate in standard reinforcement learning setting. Bellmen equations, which propagate local rewards through the state space, become unnecessary under this assumption, since human feedbacks have already summarized the future rewards into a single value \\(f_{t}\\).</p> <p>A natural idea following this assumption, then would be to apply the human feedback to direct policy gradients. Namely, to replace \\(R_{t}\\) in \\(\\mathbb{E}_{\\pi}[R_{t}\\nabla_{\\theta}ln\\pi_{\\theta}(a|s)]\\) with \\(f_{t}\\), so that we get the central update rule \\(\\theta\\leftarrow\\theta+\\mathbb{E}_{\\pi}[f_{t}\\nabla_{\\theta}ln\\pi_{\\theta}(a|s)]\\). </p> <p>There exist more considerations beyond the update rule to make DeepCoach more practical in real applications. Among them are <code>Importance Sampling</code> for correcting policy inconsistency and <code>Eligibility Trace</code> for solving sparse human feedbacks.</p> <p>With <code>Importance Sampling</code>, we correct the inconsistency between the policy used to collect experience and the policy that we are currently updating. More precisely, the update rule is adapted to \\(\\theta\\leftarrow\\theta+\\mathbb{E}_{\\pi}[\\frac{\\pi_{\\theta}(a|s)}{\\pi(a|s)}f_{t}\\nabla_{\\theta}ln\\pi_{\\theta}(a|s)]\\), where \\(\\pi\\) is the policy that was used when collecting the transition \\((s, a, s', f_{t})\\), \\(\\pi_{\\theta}\\) is the policy whose parameters we are updating currently. The purpose is to tranfer the expectation with respect to the old policy \\(\\pi\\) to the expectation with respect to the current policy \\(\\pi_{\\theta}\\), namely,</p> \\[ \\mathbb{E}_{\\pi}[\\frac{\\pi_{\\theta}(a|s)}{\\pi(a|s)}f_{t}\\nabla_{\\theta}ln\\pi_{\\theta}(a|s)] = \\mathbb{E}_{\\pi_{\\theta}}[f_{t}\\nabla_{\\theta}ln\\pi_{\\theta}(a|s)]  \\] <p>so that we are updating the policy according to the correct trajectory distribution introduced by the current policy.</p> <p><code>Eligibility Trace</code>, on the other hand, solves the issue that human feedbacks are usually scarce in a training trial. The idea is to utilize a feedback not only at the transtion where that feedback is given, but also at the previous transtions leading to the feedback. Intuitively, the purpose is to inform a trajectory rathen than a single transition at the end of the trajectory. Thus, the basic element stored in replay buffer for DeepCoach is not a single transition \\((s, a, s', f_{t})\\), but a window consisting of successive transtions that lead to a human feedback, \\([(s_{t-l}, a_{t-l}, s_{t-l+1}, 0), (s_{t-l+1}, a_{t-l+1}, s_{t-l+2}, 0),..., (s_{t}, a_{t}, s_{t+1}, f_{t})]\\), where \\(l\\) is a hyperparameter controlling the length of the window. Therefore, the update rule with respect to a window then becomes,</p> \\[ \\theta\\leftarrow\\theta+f_{t}\\sum_{i=t-l}^{t}{\\lambda^{t-i}\\frac{\\pi_{\\theta}(a_i|s_i)}{\\pi(a_i|s_i)}\\nabla_{\\theta}ln\\pi_{\\theta}(a_i|s_i)} \\] <p>where \\(\\lambda\\) is a discount factor determining how much weights we would like to give to previous transitions.</p> <p>For a complete algorithm discription, please refer to the following pseudocode.</p> <p></p> <p>In summary, DeepCoach is a policy-based reinforcement learning algorithm. It utilizes policy gradients to update its policy, while applying human feedbacks to replace discounted cumulative rewards that a critic usually approximates in Actor-Critc paradigm.</p>"},{"location":"algorithms/examples/DeepTamer.html","title":"Algorithm Example: Deep TAMER","text":"<p>A natural way for humans to guide an agent's learning is to observe its inputs and provide feedback on its actions. This translates directly to incorporating human feedback into reinforcement learning by assigning human feedback as state-action value. Deep TAMER is a prominent human-guided RL framework that leverages this concept by enabling humans to offer discrete, time-stepped positive or negative feedback. To account for human reaction time, a credit assignment mechanism maps feedback to a window of state-action pairs. A neural network \\(F\\) is trained to estimate the human feedback value, denoted as \\(\\hat{f}_{s,a}\\), for a given state-action pair \\((s, a)\\). The policy then selects the action that maximizes this predicted feedback.</p> <p>The algorithm example we provide here is enhances the original Deep TAMER in numerous ways. First, the original Deep TAMER formulation relies on DQN, which only works with discrete action spaces. We designed a continuous version of Deep TAMER while adopting state-of-the-art reinforcement learning implementation practices. We implement an actor-critic framework to handle continuous action space. Here, the critic is the human feedback estimator \\(F(s, a)\\), directly estimating human feedback instead of a target action value. The actor is parameterized by a neural network \\(A(s) = a\\), aiming to maximize the critic's output. The combined objective is defined as: \\begin{equation}     \\mathcal{L_{\\text{c-deeptamer}}} = ||F(s,A(s)) - f_{s,A(s)}||_2 - F(s, A(s)) \\end{equation} We follow recent advancements in neural architectures and hyperparameter designs. Our strong baseline not only enhances Deep TAMER to continuous actions and recent RL practices but also maintains the core methodology of integrating real-time human feedback into the learning process.</p> <p></p>"},{"location":"dojo/intro.html","title":"Dojo","text":"<p><code>Dojo</code> is an online multiplayer platform designed to facilitate the study of human-AI teams. <code>Dojo</code> is built with Unity, providing an intuitive environment for creating and training AI agents. With <code>Dojo</code>, users can create games where AI agents can collaborate or compete with humans.</p> <p><code>Dojo</code> currently offers four pre-built game examples: Bowling, Find Treasure, 1v1 Hide-and-Seek and N v N Hide-and-Seek. These games have been thoughtfully designed to be user-friendly, easy to interact with, and provide built-in interfaces to connect with AI agents.</p> <p>In addition to the pre-built games, <code>Dojo</code> includes a comprehensive set of tools that make it easy for Unity developers to design and create their own games. Using these tools, developers can quickly and effortlessly set up an online multiplayer game, connect to AI agents, customize gameplay mechanics, add new features and functionalities, and more. </p> <p>Multiple interaction modes and data collection is available with <code>Dojo</code>. Data collected from Unity can be streamed and synchronized through LabStreamingLayer.</p>"},{"location":"dojo/setup.html","title":"Setup Dojo","text":"<p>Start by cloning the repository: <pre><code>git clone https://github.com/general-robotics-duke/crew-dojo.git\n</code></pre></p> <p>Setting up a <code>Dojo</code> environment involves two key components: <code>Unity</code> and <code>Nakama</code>. Unity is a game engine and development platform that provides a range of tools for creating interactive experiences, while Nakama is an open-source server designed for real-time multiplayer games and social apps.</p> <p>The setup process involves configuring the Unity environment and launching Nakama server. Additionally, developers may need to set up and download additional tools, such as Docker, to facilitate the development process.</p>"},{"location":"dojo/setup.html#unity","title":"Unity","text":"<p>Unity is one of the crucial components of this project. Unity is a powerful game engine and development platform used to create a wide range of video games, as well as virtual and augmented reality applications. It offers a variety of features and tools for developers to create interactive experiences, including a visual editor, scripting tools, physics engine, and asset management system. Unity supports multiple platforms, such as Windows, Linux, macOS, WebGL, Android, iOS, and more, making it a popular choice for game development across different devices and platforms.</p> <p>To run the pre-existing games on Windows or Linux, users can obtain pre-built executables from the developers of this repository. This option is suitable for those who are not planning to modify or develop games in <code>Dojo</code>. If you are interested in this option, please feel free to skip the rest of this section.</p>"},{"location":"dojo/setup.html#editor-installation","title":"Editor Installation","text":"<p>Unity is the game engine used to develop all the games in the <code>Dojo</code> repository. To access Unity, users must first register for a free account on the Unity website. Once registered, proceed to the downloads page and select the appropriate installer based on the operating system. For Ubuntu systems, the application can be downloaded from the ubuntu unity website.</p> <p>After installing Unity Hub, users can log in with their registered account. Upon logging in, they will be presented with an interface similar to the following:</p> <p></p> <p>To install a Unity editor through the Unity Hub, begin by selecting the \"Installs\" option located on the left-hand panel of the interface. Then, click on the \"Install Editor\" button located in the top right corner of the screen.</p> <p></p> <p>The version of Unity utilized in the <code>Dojo</code> repository is <code>2021.3.24f1</code>. If this version is not readily available under official releases, users may locate it by selecting the \"Archive\" option. Alternatively, they may visit the Unity download archive to obtain the appropriate version.</p> <p>To proceed with the installation process, download both the game engine and editor.</p> <p>Please note that using a newer version of Unity that begins with <code>2021.3.X</code> should also be compatible with the <code>Dojo</code> repository.</p> <p>While choosing the modules, make sure that Windows (mono), Linux (mono), Mac (Mono) and WebGL builds are selected.</p> <p></p>"},{"location":"dojo/setup.html#open-dojo-project","title":"Open Dojo Project","text":"<p>To add the <code>Dojo</code> repository folder to user's Unity project, first click on the \"Projects\" tab on the Unity Hub side panel. Then, select the \"Add project from disk\" option located in the top right corner and navigate to the <code>Dojo</code> repository folder.</p> <p></p> <p>Upon opening the project in the Unity editor, the necessary packages used in <code>Dojo</code> will be automatically installed on first launch. Feel free to ignore any exceptions about <code>.meta</code> files from the console.</p> <p>To access the example games, navigate to the \"Project window\" in the Unity editor and locate the \"Assets/Examples\" folder. The example games can be found within this folder. For instance, to open the Bowling game, double-click on \"Assets/Examples/Bowling/Scenes/Bowling\" in the Project window. Please note that user's editor layouts may differ from the image provided, but the game view window should be similar to the one shown.</p> <p></p>"},{"location":"dojo/setup.html#parrelsync-setup","title":"ParrelSync Setup","text":"<p>In the \"Hierarchy window\", all of the game objects used in the current scene can be found. For example, in Bowling, notice the presence of <code>GameManager_Client</code> and <code>GameManager_Server</code>. These objects are used in multiplayer games over a network, where one game instance runs as a server, authorizing actions from all connected clients. The authoritative server is crucial to ensure that the game view remains consistent across all clients. Therefore, when using Unity Editor, users have the option of playing the game in either server mode or client mode.</p> <p>Due to the need to debug the game by running one editor as server and the other as client, it is highly recommended to setup ParrelSync, a Unity package installed that enables users to launch another Unity editor on the same project.</p> <p>First, locate \"ParrelSync\" on the editor menu. Click \"ParrelSync/Clone Manager\" to open the manager window. Users will have the option to create as many clones of the <code>Dojo</code> project as they like.</p> <p></p> <p>After cloning, click \"Open in New Editor\" to launch another editor window. Then, in \"Hierarchy window\", disable GameManager_Server and enable GameManager_Client to play in client mode. Notice that only one of the two managers will be need to be enabled at a time.</p>"},{"location":"dojo/setup.html#build-a-game","title":"Build a Game","text":"<p>To generate a game build, locate \"DojoBuilder\" in editor menu and open \"Dojo Example Builder\" window.</p> <p></p> <p>Enable the games to build and customize the builder configurations. By default, a \"Builds\" folder will be created under <code>Dojo</code> folder and game builds will be exported there.</p>"},{"location":"dojo/setup.html#nakama","title":"Nakama","text":"<p>Nakama is a crucial framework that facilitates game hosting, client identity, and matchmaking. By utilizing Nakama, <code>Dojo</code> can connect clients over the internet and enable them to join the same game match. To begin using Nakama, Docker is necessary.</p>"},{"location":"dojo/setup.html#docker-installation","title":"Docker Installation","text":"<p>Docker is a popular containerization platform that allows developers to package and deploy applications as self-contained units, called containers. Containers provide a lightweight and efficient way to isolate and run applications, ensuring that they can run consistently across different environments and platforms. With Docker, developers can easily build, test, and deploy applications in a reliable and reproducible way, without worrying about conflicts or dependencies.</p> <p>After installing and launching Docker service, open \"Nakama\" folder in <code>Dojo</code> repository. Run <code>run.sh</code> or <code>run.bat</code> depending on the operating system. Verify that the container called <code>dojo-nakama-server</code> has started running.</p> <p></p> <p>Note: If nakama container failed, it may be a version change of Nakama packages. To resolve this, remove go.mod and go.sum and run the script again.</p> <p>If an error indicating \"vendor\" folder not exist, this may be caused by go package url. Run the following to resolve it: <pre><code>go env -w GOPROXY=\"https://goproxy.io\"\n</code></pre></p>"},{"location":"dojo/setup.html#nakama-console","title":"Nakama Console","text":"<p>Nakama server comes with a console. After launching the containers, open http://127.0.0.1:7351/ in browser to view the connected users and ongoing matches.</p> <p>The default username is <code>admin</code>. Default password is <code>password</code>.</p>"},{"location":"dojo/setup.html#linux-specific-steps","title":"Linux-specific Steps","text":"<p>On Linux environment, you may need to configure <code>/etc/hosts</code> file and add following line so that <code>host.docker.internal</code> DNS resolute to the Docker container IP address.</p> <pre><code>172.17.0.1    host.docker.internal\n</code></pre> <p>By default, each server built Unity instance will try to connect Docker via <code>host.docker.internal</code> address. Make sure this path exists for the system environment where the Instance Server will be running.</p>"},{"location":"dojo/components/design.html","title":"Dojo Design","text":"<p>On this page, you will find a comprehensive explanation of the design pattern utilized by <code>Dojo</code>.</p>"},{"location":"dojo/components/design.html#folder-structure","title":"Folder Structure","text":"<p>When working with the <code>Dojo</code> repository, it's important to focus on two key folders:  <code>Nakama</code>, and <code>Unity</code>.</p> <ul> <li><code>Nakama</code> folder is where you'll find the Docker file and Nakama module implementations.</li> <li><code>Unity</code> folder is the core of the <code>Dojo</code> package, as it contains both the package itself and example games. It is also the folder that will be opened by Unity editor.</li> </ul>"},{"location":"dojo/components/design.html#unity-folder","title":"Unity Folder","text":"<p>The code inside the Unity folder is split into two parts: the <code>Dojo</code> package code and the example games code.</p> <ul> <li><code>Unity/Assets/Dojo</code> has all the code implementation for <code>Dojo</code> package.</li> <li><code>Unity/Assets/Examples</code> contains all the example game implementations.</li> </ul>"},{"location":"dojo/components/design.html#dojo-package","title":"Dojo Package","text":"<p><code>Dojo</code> package has following layout: <pre><code>Agent/\nEditor/\nMujoco/\nNakama/\nNetcode/\nPlugins/\nRecording/\nUI/\nDispatcher.cs\nDojoConnection.cs\nDojoMessage.cs\nDojoNetworkRole.cs\n</code></pre></p> <ul> <li><code>Agent</code> folder provide code for Unity ml-agents integration.</li> <li><code>Editor</code> has code that only runs in Unity editor, such as game builder scripts.</li> <li><code>Mujoco</code> contains the integration code for Mujoco physics engine.</li> <li><code>Nakama</code> integrates the Nakama multiplayer framework.</li> <li><code>Netcode</code> integrates the Unity Netcode for GameObjects.</li> <li><code>Plugins</code> contains system-specific binary files that are used in <code>Dojo</code>.</li> <li><code>Recording</code> provides code for recording game play information.</li> <li><code>UI</code> implements the user interface for human players and viewers.</li> </ul> <p>Finally, <code>DojoConnection.cs</code> is the script responsible for orchestrating the package and ensuring smooth operation by connecting all its components.</p>"},{"location":"dojo/components/design.html#dojo-examples","title":"Dojo Examples","text":"<p>The example games follow a specific folder structure pattern:</p> <ul> <li>The parent folder is the name of the game.</li> <li><code>Actions</code> contains all the keyboard/mouse action maps.</li> <li><code>Configs</code> has the configuration files used for this game.</li> <li><code>Materials</code> has the shader/physics materials used in game.</li> <li><code>Prefabs</code> contains the prefabs in Unity.</li> <li><code>Scenes</code> is where the scene files locate.</li> <li><code>Scripts</code> contains all the code in the game.</li> <li><code>Shaders</code> has custom shader implementations.</li> <li><code>Textures</code> contains any image textures used in the game.</li> <li><code>UIBuilder</code> has any custom user interface configuration for this game.</li> </ul> <p>In conclusion, open a game scene by navigating to the <code>Scenes</code> folder.</p>"},{"location":"dojo/components/design.html#dojo-components","title":"Dojo Components","text":"<p>A standard <code>Dojo</code> game is composed of the following elements:</p> <p></p> <p>The game is based on the Nakama framework and incorporates the <code>Dojo</code> Nakama integration. Additionally, it employs a human interface for human interactions, utilizes ml-agents integration for communicating with the <code>Algorithms</code> code, and integrates netcode for game state synchronization.</p>"},{"location":"dojo/components/interface.html","title":"Human Interface","text":"<p><code>Dojo</code> offers a pre-built user interface, known as <code>DojoMenu</code>, that enables human players or viewers to interact with the program in an intuitive manner.</p>"},{"location":"dojo/components/interface.html#nakama-login","title":"Nakama Login","text":"<p>When launching a client instance, a login panel will be displayed:</p> <p></p> <p>Please note that the \"IP Address\" field refers to the target Nakama server IP address, while the \"Name\" field displays the current client's name on Nakama after login. It's important to keep in mind that the top left and top right panels will still be empty at this point, with the top left panel showing a red bar to indicate that the current client is in a logout state.</p>"},{"location":"dojo/components/interface.html#match-selection","title":"Match Selection","text":"<p>Upon logging in, a list of currently active matches will be presented:</p> <p></p> <p>To request a new match hosted by a server from the Instance Server, the user can click the \"New Match\" button. Alternatively, the user can choose an available match from the list and click \"Join Match\".</p> <p></p>"},{"location":"dojo/components/interface.html#client-information","title":"Client Information","text":"<p>Once the match is joined, the user interface will resemble the following:</p> <p></p> <p>The top left panel shows the display name, the match ID assigned by Nakama, the current client role, and a login status bar. Users can switch between the \"Player\" and \"Viewer\" roles by clicking on the role menu. Clicking on the green status bar will log the user out of Nakama and prompt them to return to the login panel.</p> <p></p> <p>Due to a UI bug in Unity, selecting options from the menu using a mouse may not be stable. As a workaround, users can switch between menu options by clicking on the menu and using the up/down arrows on the keyboard.</p> <p>The top right panel displays a list of clients who are actively participating in the same match, along with their display name and current role. By clicking on a client that is AI player, users can select them as feedback targets. Users can also filter the list to only show clients who are currently in a <code>Player</code> role, making it easier to find feedback targets.</p>"},{"location":"dojo/components/mujoco.html","title":"Mujoco Integration","text":"<p>MuJoCo is short for Multi-Joint dynamics with Contact, a physics engine designed for various applications including robotics, biomechanics, graphics and animation, machine learning, and other fields that require precise and quick simulation of articulated structures interacting with their surroundings. Originally created by Roboti LLC, it was later acquired by DeepMind in October 2021 and subsequently made freely accessible. In May 2022, it was also open-sourced, and its codebase is now accessible on the deepmind/mujoco repository on GitHub.</p> <p><code>Dojo</code> provides built-in integration to use Mujoco as its physics engine.</p>"},{"location":"dojo/components/mujoco.html#mujoco-models","title":"Mujoco Models","text":"<p>Any xml model supported by Mujoco can be imported by \"Import MuJoCo Scene\" button.</p> <p></p> <p>A game object will be created in the current scene. Make the object a prefab by dragging it into a project folder.</p>"},{"location":"dojo/components/mujoco.html#prefab-config","title":"Prefab Config","text":"<p>Click on the prefab and attach <code>DojoMujoco</code> script component.</p> <p></p> <p>Click the \"Inject\" button to apply <code>NetworkTransform</code> to all game objects that are Mujoco joints. To ensure smooth object movements, enable interpolation for all <code>NetworkTransform</code> by clicking \"Enable Interpolation\". Lastly, fix any renderer bugs caused by the Mujoco models by clicking \"Fix MjGeom Renderer\".</p>"},{"location":"dojo/components/networking.html","title":"Multiplayer Networking","text":"<p><code>Dojo</code>'s core feature includes networking, allowing any game developed with <code>Dojo</code> to be multiplayer over the Internet by default. This setup enables players and AI agents to access the game from anywhere in the world, greatly enhancing the research's accessibility and encouraging collaborations with individuals beyond the research lab.</p>"},{"location":"dojo/components/networking.html#game-networking","title":"Game Networking","text":"<p>Two packages, Nakama and Unity netcode, enable multiplayer networking in the game. Nakama manages the connection between Unity instances, providing each with a unique identity and allowing them to discover and join the same match for interaction. Meanwhile, Unity netcode builds on top of Nakama as a transport layer, facilitating game state synchronization and ensuring fair gameplay across all clients.</p>"},{"location":"dojo/components/networking.html#networking-model","title":"Networking Model","text":"<p>By default, <code>Dojo</code> utilizes a server-client networking model to facilitate easy game synchronization. This model involves a single server and one or more clients per game. Whenever a client initiates an action, it transmits its command to the server, which then determines the order in which the actions are executed and updates the game state accordingly. Finally, the server broadcasts the latest game state to all clients, ensuring that each client observes the exact same game state.</p> <p>For <code>Dojo</code>, both the server and client connect to the same Nakama server to transport their messages. Although they have different roles in <code>Dojo</code>, they are both clients of the Nakama server.</p> <p></p>"},{"location":"dojo/components/networking.html#match","title":"Match","text":"<p>Nakama offers a robust match-making system that enables users to join independent games and communicate with one another in real-time. This functionality can be likened to a virtual room where players can meet and interact. By leveraging the match system, <code>Dojo</code> is capable of hosting numerous games simultaneously using just a single Nakama server. Players can easily join any game by simply following the corresponding match ID.</p>"},{"location":"dojo/components/networking.html#identity","title":"Identity","text":"<p>Each Unity instance acts as a client to the Nakama server, and upon initial connection, it receives a unique identity from Nakama. This identity is used to track and identify instances within the same game. While Nakama prefers to maintain the persistent identity of each Unity instance, <code>Dojo</code> does not follow this approach. Instead, we have implemented code to automatically delete identity information when an instance disconnects, effectively avoiding this feature.</p>"},{"location":"dojo/components/networking.html#role","title":"Role","text":"<p><code>Dojo</code> facilitates effortless development of human-AI multiplayer games by assigning a unique abstract identity to each Unity instance in the game. The network roles available in the game include:</p> <ul> <li>Server</li> <li>Player</li> <li>Viewer</li> </ul> <p>The <code>Server</code> instance is the primary instance that hosts a Nakama match. This authoritative instance enables other clients to discover and join the same match, allowing them to start playing the game. Only one <code>Server</code> instance is necessary per match.</p> <p>On the other hand, a <code>Player</code> instance is the human client that acts as the <code>player</code> in the game, while a <code>Viewer</code> instance is the human client that can only observe the game without the ability to affect game states. The primary difference between a <code>Player</code> and a <code>Viewer</code> is that a <code>Player</code> has the ability to interact with the game and change game states.</p>"},{"location":"dojo/components/networking.html#configuration","title":"Configuration","text":"<p><code>Dojo</code> offers game-specific configurations in addition to network roles. These configurations allow developers to define the game tag, ensuring that clients only connect to servers running the same game. Additionally, developers can set a maximum number of players for the game, which is useful for developing single-player games like Tetris. While there is no limit to the number of viewers for any game, the maximum number of allowed players is enforced.</p>"},{"location":"dojo/components/networking.html#ai-networking","title":"AI Networking","text":"<p>Nakama has a unique design that facilitates effortless connection to currently operational AI policy programs. Unity ml-agents enables AI networking. Usually, the AI players run on a <code>Server</code> instance, while the <code>Algorithms</code> created AI policy programs operate on the same machine as the <code>Server</code> instance.</p>"},{"location":"dojo/components/networking.html#human-ai-connection","title":"Human-AI Connection","text":"<p>Unity netcode manages the interaction between humans and AI in the game, while the Nakama layer enables human clients to send customized messages to the AI. When a <code>Viewer</code> instance initiates human feedback, the message is sent to the server with the agent ID, which is then transported through Unity ml-agents to the running policy on the <code>Algorithms</code> side.</p>"},{"location":"dojo/components/games/1v1_hide_and_seek.html","title":"1 v 1 Hide and Seek","text":"<p>One-on-one visual hide-and-seek has two players, a hider and a seeker. The seeker's goal is to navigate through the maze and catch the hider. The hider's goal is to remain uncaught throughout the game.</p>"},{"location":"dojo/components/games/1v1_hide_and_seek.html#action-space","title":"Action Space","text":"<p>A 2-dimensional continuous action space:</p> <ul> <li><code>NEXT_DESTINATION_X</code> (0)</li> <li><code>NEXT_DESTINATION_Y</code> (1)</li> </ul>"},{"location":"dojo/components/games/1v1_hide_and_seek.html#observation-space","title":"Observation Space","text":"<p>Hide and Seek provides 3 possible camera views, all 128x128 size with bounding box: <pre><code>Top Left:       (0.0, 0.0)\nWidth Height:   (1.0, 1.0)\n</code></pre></p>"},{"location":"dojo/components/games/1v1_hide_and_seek.html#first-person-view","title":"First Person View","text":"<p>The first person view of the player.</p> <p></p>"},{"location":"dojo/components/games/1v1_hide_and_seek.html#masked-view","title":"Masked View","text":"<p>The top-down view with masked square area around the player.</p> <p></p>"},{"location":"dojo/components/games/1v1_hide_and_seek.html#accumulative-view","title":"Accumulative View","text":"<p>Similar top-down view with masked square area around the player, with the map view of player's visited area.</p> <p></p>"},{"location":"dojo/components/games/1v1_hide_and_seek.html#unity-parameters","title":"Unity Parameters","text":"<p>Game specific parameters:</p> Parameter Name Parameter Format Description <code>-MoveSpeed</code> float Moving speed of the AI agent <code>-RotationSpeed</code> float Rotation speed of the AI agent <code>-EventChannelID</code> string Event side channel assigned by <code>Algorithms</code> <code>-GameStopChannelID</code> string GameStop side channel assigned by <code>Algorithms</code> <code>-DisableFirstCamera</code> none Flag to disable first person camera view <code>-DisableMaskedCamera</code> none Flag to disable masked camera view <code>-DisableAccumuCamera</code> none Flag to disable accumulative camera <code>-MatchStartNumHiders</code> integer Overwrite the number of hiders required to start an episode <code>-MatchStartNumSeekers</code> integer Overwrite the number of seekers required to start an episode <code>-DecisionRequestFrequency</code> float Number of seconds between each two decision requests <p>Universal parameters:</p> Parameter Name Parameter Format Description <code>-NakamaID</code> string Server ID assigned by Instance Server <code>-DojoScreenSize</code> <code>int</code>x<code>int</code> Set window size on launch <code>-DojoScreenPos</code> <code>int</code>,<code>int</code> Set window position on launch <code>-DojoMonitorID</code> integer Set window monitor on launch <code>-CaptureSizeW</code> integer Camera capture size (width) <code>-CaptureSizeH</code> integer Camera capture size (height) <code>-DojoRecording</code> none Flag to enable recording <code>-DojoRecordingFile</code> string To overwrite recording log file path <code>-DojoRecordingIdentity</code> string To overwrite recording log identity <p>User interface controls:</p> Action Name Keyboard Mapping Toggle UI <code>ESC</code>"},{"location":"dojo/components/games/bowling.html","title":"Bowling","text":"<p>Bowling is a classic arcade game released by Atari in 1979. The game simulates the experience of bowling with a trackball controller that allows players to aim and throw the ball down the virtual lane. The objective of the game is to knock down as many pins as possible and score as many points as you can.</p>"},{"location":"dojo/components/games/bowling.html#action-space","title":"Action Space","text":"<p>A 3-dimensional continuous action space:</p> <ul> <li><code>RELEASE POSITION</code> (0)</li> <li><code>DISTANCE TO STEER</code> (1)</li> <li><code>DIRECTION TO STEER</code> (2)</li> </ul>"},{"location":"dojo/components/games/bowling.html#observation-space","title":"Observation Space","text":"<p>320x320 camera view with bounding box: <pre><code>Top Left:       (0.0, 0.5)\nWidth Height:   (1.0, 0.5)\n</code></pre></p>"},{"location":"dojo/components/games/bowling.html#unity-parameters","title":"Unity Parameters","text":"<p>Game specific parameters:</p> Parameter Name Parameter Format Description <code>-NumAgents</code> integer Number of AI agents <code>-EventChannelID</code> string Event side channel assigned by <code>Algorithms</code> <code>-GameStopChannelID</code> string GameStop side channel assigned by <code>Algorithms</code> <p>Universal parameters:</p> Parameter Name Parameter Format Description <code>-NakamaID</code> string Server ID assigned by Instance Server <code>-DojoScreenSize</code> <code>int</code>x<code>int</code> Set window size on launch <code>-DojoScreenPos</code> <code>int</code>,<code>int</code> Set window position on launch <code>-DojoMonitorID</code> integer Set window monitor on launch <code>-CaptureSizeW</code> integer Camera capture size (width) <code>-CaptureSizeH</code> integer Camera capture size (height) <code>-DojoRecording</code> none Flag to enable recording <code>-DojoRecordingFile</code> string To overwrite recording log file path <code>-DojoRecordingIdentity</code> string To overwrite recording log identity"},{"location":"dojo/components/games/bowling.html#human-keyboard-control","title":"Human Keyboard Control","text":"<p>Game play controls:</p> Action Name Keyboard Mapping Move up <code>Up Arrow</code> Move down <code>Down Arrow</code> Shoot <code>Space</code> <p>User interface controls:</p> Action Name Keyboard Mapping Toggle UI <code>ESC</code>"},{"location":"dojo/components/games/find_treasure.html","title":"Find Treasure","text":"<p>The agent is tasked to navigate through a partially observable maze to retrieve a treasure. The agents receive a +10 reward upon reaching the treasure, and a constant -1 time penalty for each step taken. The observation space is a top-down accumulated view of where the agent has explored, initialized by a square area around the agent. The action space is a two-dimensional vector of the next destination coordinates, to which a low-level planning algorithm will navigate the agent. The max episode length is 15 seconds.</p>"},{"location":"dojo/components/games/find_treasure.html#action-space","title":"Action Space","text":"<p>A 2-dimensional continuous action space:</p> <ul> <li><code>NEXT_DESTINATION_X</code> (0)</li> <li><code>NEXT_DESTINATION_Y</code> (1)</li> </ul>"},{"location":"dojo/components/games/find_treasure.html#observation-space","title":"Observation Space","text":"<p>320x320 camera view with bounding box: <pre><code>Top Left:       (0.0, 0.5)\nWidth Height:   (1.0, 0.5)\n</code></pre></p>"},{"location":"dojo/components/games/find_treasure.html#unity-parameters","title":"Unity Parameters","text":"<p>Game specific parameters:</p> Parameter Name Parameter Format Description <code>-NumAgents</code> integer Number of AI agents <code>-EventChannelID</code> string Event side channel assigned by <code>Algorithms</code> <code>-GameStopChannelID</code> string GameStop side channel assigned by <code>Algorithms</code> <p>Universal parameters:</p> Parameter Name Parameter Format Description <code>-NakamaID</code> string Server ID assigned by Instance Server <code>-DojoScreenSize</code> <code>int</code>x<code>int</code> Set window size on launch <code>-DojoScreenPos</code> <code>int</code>,<code>int</code> Set window position on launch <code>-DojoMonitorID</code> integer Set window monitor on launch <code>-CaptureSizeW</code> integer Camera capture size (width) <code>-CaptureSizeH</code> integer Camera capture size (height) <code>-DojoRecording</code> none Flag to enable recording <code>-DojoRecordingFile</code> string To overwrite recording log file path <code>-DojoRecordingIdentity</code> string To overwrite recording log identity <p>User interface controls:</p> Action Name Keyboard Mapping Toggle UI <code>ESC</code>"},{"location":"dojo/components/games/new_game.html","title":"New Game","text":"<p>This section demonstrates some recommended steps to set up a new game environment in <code>Dojo</code>.</p>"},{"location":"dojo/components/games/new_game.html#game-folder","title":"Game Folder","text":"<p>In Unity editor, create the following folder structure for the game.</p> <p></p> <p>Create a scene file under <code>Scenes</code> folder and double click it.</p> <p></p>"},{"location":"dojo/components/games/new_game.html#scene-setup","title":"Scene Setup","text":"<p>Now from the hierarchy panel, create following empty game objects:</p> <p></p> <p>The <code>Environment</code> object will contain all static game objects in the scene. <code>NetworkManager</code> is preserved for Unity's netcode system. <code>DojoClient</code> and <code>DojoServer</code> are two components that serve as the basic layer for establishing a connection with the Nakama server. The <code>GameManager</code> object will hold any scripts specific to the game.</p>"},{"location":"dojo/components/games/new_game.html#nakama","title":"Nakama","text":"<p>For multiplayer networking to function, you'll need to establish a connection with the Nakama server. This can be achieved by configuring the <code>DojoConnection</code> script from the <code>Dojo</code> package for both the server and client components.</p> <p>To get started, select the <code>DojoClient</code> and add the <code>DojoConnection</code> component script via the Inspector panel. Ensure that the \"Is Client\" checkbox is ticked.</p> <p></p> <p>Do the same for <code>DojoServer</code> object, except that \"Is Client\" is not ticked. Now disable <code>DojoClient</code> and this game will run in server mode in the editor.</p> <p></p>"},{"location":"dojo/components/games/new_game.html#netcode","title":"Netcode","text":"<p>Now that the game is able to connect to the Nakama server, it is recommended to setup Unity netcode as well to handle game state synchronizations automatically.</p> <p>Start by creating a child empty game object called <code>Transport</code> within the <code>NetworkManager</code> object. This object will hold the customized <code>DojoTransport</code> that has been built for Unity netcode integration.</p> <p></p> <p>Next, attach the <code>NetworkManager</code> component script from Unity netcode to the <code>NetworkManager</code> object and the <code>DojoTransport</code> script from <code>Dojo</code> to the <code>Transport</code> object.</p> <p></p> <p></p> <p>Then, drag the <code>Transport</code> game object to the \"Network Transport\" entry in the <code>NetworkManager</code> object.</p> <p></p> <p>Lastly, attach the <code>DojoNetcodeHelper</code> script component to the <code>NetworkManager</code> object.</p> <p></p> <p>The above steps enables Unity netcode to funtion by utilizing the Nakama client-client connections as the underlying transport layer.</p>"},{"location":"dojo/components/games/new_game.html#user-interface","title":"User Interface","text":"<p><code>Dojo</code> includes a user-friendly interface that human players can easily interact with.</p> <p>First, locate the <code>DojoMenu</code> prefab from the folder \"Dojo/UI\".</p> <p></p> <p>Then, drag the prefab into the scene and place at the bottom of the hierarchy.</p> <p></p>"},{"location":"dojo/components/games/new_game.html#configurations","title":"Configurations","text":"<p>The last step is to setup configuration files that allow the game to connect with Nakama server and build successfully.</p>"},{"location":"dojo/components/games/new_game.html#nakama-configs","title":"Nakama Configs","text":"<p>Simply right-click within the <code>Configs</code> folder and select \"Create/Dojo/Nakama Match Configurations\" to create a Nakama configuration file.</p> <p></p> <p>To configure your game, simply click on the config file and adjust the \"Game Tag\" and \"Max Num Players\" in the inspector panel to match the specifications of your game.</p> <p>Finally, drag the file into <code>DojoClient</code> and <code>DojoServer</code> script components.</p> <p></p>"},{"location":"dojo/components/games/new_game.html#build-configs","title":"Build Configs","text":"<p><code>Dojo</code> provides easy building scripts to help build the game in both server and client mode for multiple platforms.</p> <p>Same as Nakama config file, right-click in <code>Configs</code> folder and select \"Create/Dojo/BuilderConfig\" to create a build configuration file. Rename the file by the name of your game. Then click the file and fill in the values in inspector panel.</p> <p>\"Scene Path\" is the relative path to the scene file from Unity root folder. In this example, it is the following: <pre><code>Assets/Examples/Template/Scenes/Template.unity\n</code></pre></p> <p>\"Scene Name\" will be the unique game name. \"Output Path\" is the output folder path to store all build artifacts. By default, the output path is <code>../Builds</code>.</p> <p>Finally, the \"Dojo Server Name\" and \"Dojo Client Name\" are the names of the game objects. In this case, <code>DojoServer</code> and <code>DojoClient</code>.</p> <p></p> <p>Finally, add the build config file to the <code>DojoBuilder</code> list from the Unity editor.</p> <p></p>"},{"location":"dojo/components/games/nvn_hide_and_seek.html","title":"N v N Hide and Seek","text":"<p>A multiplayer version of Hide and Seek. The seekers' goal is to navigate through the maze and catch the hiders. The hiders' goal is to remain uncaught throughout the game.</p>"},{"location":"dojo/components/games/nvn_hide_and_seek.html#action-space","title":"Action Space","text":"<p>A 2-dimensional continuous action space:</p> <ul> <li><code>NEXT_DESTINATION_X</code> (0)</li> <li><code>NEXT_DESTINATION_Y</code> (1)</li> </ul>"},{"location":"dojo/components/games/nvn_hide_and_seek.html#observation-space","title":"Observation Space","text":"<p>Hide and Seek provides 3 possible camera views, all 128x128 size with bounding box: <pre><code>Top Left:       (0.0, 0.0)\nWidth Height:   (1.0, 1.0)\n</code></pre></p>"},{"location":"dojo/components/games/nvn_hide_and_seek.html#first-person-view","title":"First Person View","text":"<p>The first person view of the player.</p> <p></p>"},{"location":"dojo/components/games/nvn_hide_and_seek.html#masked-view","title":"Masked View","text":"<p>The top-down view with masked square area around the player.</p> <p></p>"},{"location":"dojo/components/games/nvn_hide_and_seek.html#accumulative-view","title":"Accumulative View","text":"<p>Similar top-down view with masked square area around the player, with the map view of player's visited area.</p> <p></p>"},{"location":"dojo/components/games/nvn_hide_and_seek.html#unity-parameters","title":"Unity Parameters","text":"<p>Game specific parameters:</p> Parameter Name Parameter Format Description <code>-NumHiders</code> integer Number of AI agents as Hiders <code>-NumSeekers</code> integer Number of AI agents as Seekers <code>-MoveSpeed</code> float Moving speed of the AI agent <code>-RotationSpeed</code> float Rotation speed of the AI agent <code>-EventChannelID</code> string Event side channel assigned by <code>Algorithms</code> <code>-GameStopChannelID</code> string GameStop side channel assigned by <code>Algorithms</code> <code>-DisableFirstCamera</code> none Flag to disable first person camera view <code>-DisableMaskedCamera</code> none Flag to disable masked camera view <code>-DisableAccumuCamera</code> none Flag to disable accumulative camera <code>-MatchStartNumHiders</code> integer Overwrite the number of hiders required to start an episode <code>-MatchStartNumSeekers</code> integer Overwrite the number of seekers required to start an episode <code>-DecisionRequestFrequency</code> float Number of seconds between each two decision requests <p>Universal parameters:</p> Parameter Name Parameter Format Description <code>-NakamaID</code> string Server ID assigned by Instance Server <code>-DojoScreenSize</code> <code>int</code>x<code>int</code> Set window size on launch <code>-DojoScreenPos</code> <code>int</code>,<code>int</code> Set window position on launch <code>-DojoMonitorID</code> integer Set window monitor on launch <code>-CaptureSizeW</code> integer Camera capture size (width) <code>-CaptureSizeH</code> integer Camera capture size (height) <code>-DojoRecording</code> none Flag to enable recording <code>-DojoRecordingFile</code> string To overwrite recording log file path <code>-DojoRecordingIdentity</code> string To overwrite recording log identity <p>User interface controls:</p> Action Name Keyboard Mapping Toggle UI <code>ESC</code>"}]}